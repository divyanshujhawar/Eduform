{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0) t[p[i]] = s[p[i]];\n  return t;\n};\n\nimport * as React from 'react';\nimport { FormContext } from './FormContext';\n/**\n * Represents the Field component that is used inside the KendoReact Form component.\n * It uses `name` property to access field value and meta information from Form state.\n */\n\nexport var Field = function (props) {\n  var name = props.name,\n      component = props.component,\n      validator = props.validator,\n      children = props.children,\n      others = __rest(props, [\"name\", \"component\", \"validator\", \"children\"]);\n\n  var form = React.useContext(FormContext);\n  var formId = form ? form.id : '';\n  React.useEffect(function () {\n    if (!form) {\n      return;\n    }\n\n    var unregisterField = form.registerField(name, validator);\n    return unregisterField;\n  }, [name, formId, validator]);\n  var onChange = React.useCallback(function (event) {\n    // Adding a name here slows down the performance.\n    // However, the other apprach taken by Formik is to search for the `name` attribute\n    // on `event.target.value` which does not work for all KendoReact components.\n    // If Formik uses custom components like the KendoReact ones, it would take the same approach.\n    // On the other hand, ReactFinal Form performs better in both cases due to its\n    // subscribtion-based model - the fields are subscribed for changes to a given field,\n    // which prevents unnececery rerenders. Note that this might be fragile in future React versions -\n    // the current performance testing accunts for a slight lag after 300 native HTML inputs in the 120ms-200ms range.\n    var newValue = event ? event.value !== undefined ? event.value : event.target ? event.target.value : event.target : event;\n    form.onChange(name, {\n      value: newValue\n    });\n  }, [name, formId]);\n  var onNativeComponentChange = React.useCallback(function (event) {\n    return form.onChange(name, {\n      value: event.target.value\n    });\n  }, [name, formId]);\n  var onBlur = React.useCallback(function () {\n    return form.onBlur(name);\n  }, [name, formId]);\n  var onFocus = React.useCallback(function () {\n    return form.onFocus(name);\n  }, [name, formId]);\n\n  if (!form) {\n    // TODO: For future versions - warn for missing form in dev mode\n    // if (__process.env.NODE_ENV !== 'production') { // or __DEV__\n    //     throw new Error('Field must be used inside of a <Form> component');\n    // }\n    return null;\n  }\n\n  var value = form.valueGetter(name); // TODO: For future versions as it's better to have render prop\n  // if (typeof children === 'function') {\n  //     return children({ ...field, children: undefined, ...others });\n  // }\n\n  if (typeof component === 'string') {\n    // ignore meta, combine input with any other props\n    return React.createElement(component, __assign({\n      onChange: onNativeComponentChange,\n      onBlur: onBlur,\n      onFocus: onFocus,\n      value: value,\n      children: children\n    }, others));\n  }\n\n  return React.createElement(component, __assign({\n    // input\n    onChange: onChange,\n    onBlur: onBlur,\n    onFocus: onFocus,\n    value: value,\n    // meta\n    validationMessage: form.errors[name],\n    touched: form.touched[name],\n    modified: form.modified[name],\n    visited: form.visited[name],\n    // Our `valid` implementation requires double submit to show html5 validation errors,\n    // however it's NOT recommended to show html5 validation errors at all as:\n    // - There is no standard way to change validation look and feel with CSS.\n    // - Look different in each browser / OS\n    // - You can have a page in one language but an error message displayed in another language (not localizable)\n    valid: !(Boolean(form.errors[name]) && form.touched[name]),\n    children: children,\n    name: name\n  }, others));\n};\nField.displayName = 'KendoReactField';","map":{"version":3,"sources":["../../src/Field.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nimport * as React from 'react';\nimport { FormContext } from './FormContext';\n/**\n * Represents the Field component that is used inside the KendoReact Form component.\n * It uses `name` property to access field value and meta information from Form state.\n */\nexport var Field = function (props) {\n    var name = props.name, component = props.component, validator = props.validator, children = props.children, others = __rest(props, [\"name\", \"component\", \"validator\", \"children\"]);\n    var form = React.useContext(FormContext);\n    var formId = form ? form.id : '';\n    React.useEffect(function () {\n        if (!form) {\n            return;\n        }\n        var unregisterField = form.registerField(name, validator);\n        return unregisterField;\n    }, [name, formId, validator]);\n    var onChange = React.useCallback(function (event) {\n        // Adding a name here slows down the performance.\n        // However, the other apprach taken by Formik is to search for the `name` attribute\n        // on `event.target.value` which does not work for all KendoReact components.\n        // If Formik uses custom components like the KendoReact ones, it would take the same approach.\n        // On the other hand, ReactFinal Form performs better in both cases due to its\n        // subscribtion-based model - the fields are subscribed for changes to a given field,\n        // which prevents unnececery rerenders. Note that this might be fragile in future React versions -\n        // the current performance testing accunts for a slight lag after 300 native HTML inputs in the 120ms-200ms range.\n        var newValue = event\n            ? (event.value !== undefined\n                ? event.value\n                : (event.target\n                    ? event.target.value\n                    : event.target))\n            : event;\n        form.onChange(name, { value: newValue });\n    }, [name, formId]);\n    var onNativeComponentChange = React.useCallback(function (event) { return form.onChange(name, { value: event.target.value }); }, [name, formId]);\n    var onBlur = React.useCallback(function () { return form.onBlur(name); }, [name, formId]);\n    var onFocus = React.useCallback(function () { return form.onFocus(name); }, [name, formId]);\n    if (!form) {\n        // TODO: For future versions - warn for missing form in dev mode\n        // if (__process.env.NODE_ENV !== 'production') { // or __DEV__\n        //     throw new Error('Field must be used inside of a <Form> component');\n        // }\n        return null;\n    }\n    var value = form.valueGetter(name);\n    // TODO: For future versions as it's better to have render prop\n    // if (typeof children === 'function') {\n    //     return children({ ...field, children: undefined, ...others });\n    // }\n    if (typeof component === 'string') {\n        // ignore meta, combine input with any other props\n        return React.createElement(component, __assign({ onChange: onNativeComponentChange, onBlur: onBlur, onFocus: onFocus, value: value, children: children }, others));\n    }\n    return React.createElement(component, __assign({ \n        // input\n        onChange: onChange, onBlur: onBlur, onFocus: onFocus, value: value, \n        // meta\n        validationMessage: form.errors[name], touched: form.touched[name], modified: form.modified[name], visited: form.visited[name], \n        // Our `valid` implementation requires double submit to show html5 validation errors,\n        // however it's NOT recommended to show html5 validation errors at all as:\n        // - There is no standard way to change validation look and feel with CSS.\n        // - Look different in each browser / OS\n        // - You can have a page in one language but an error message displayed in another language (not localizable)\n        valid: !(Boolean(form.errors[name]) && form.touched[name]), children: children, name: name }, others));\n};\nField.displayName = 'KendoReactField';\n//# sourceMappingURL=Field.js.map"]},"metadata":{},"sourceType":"module"}